#!/usr/bin/env python3
###########################################################
#  CROCO cmake build system, under CeCILL-C
#  From SÃ©bastien Valat (INRIA & LJK) - 2023
#  CROCO website : http://www.croco-ocean.org
###########################################################

###########################################################
# The goal of this file is to extract the CPPKEY par from cppdefs.h
# corresponding to the CASE selected in the build system.
#
# In addition of this extraction we also remove the #undef related
# to the user_keys so the user can easily activate de-activate what
# he wants in the cppdefs_override.h file.

###########################################################
import os
import re
import sys
import argparse

###########################################################
def dump_user_define(case: str, user_keys: dict) -> str:
    '''
    Dump the user defined CPP keys.

    Parameters:
    -----------
    case: str
        The selected case.
    user_keys: dict
        List of CPP keys defined and forced by user.
    '''
    # vars
    lines = []

    # print separator
    lines.append("/********** USER CONFIG (generated by ./cppdef_handler.py) ******************/")

    # case
    lines.append("/* SELECTED CASE */")
    lines.append(f"#define {case}")
    lines.append("")

    # dump all keys
    lines.append("/* FEATURES */")
    for key, value in user_keys.items():
        if value:
            lines.append(f"#define {key}")
        else:
            lines.append(f"#undef {key}")

    # ok
    return '\n'.join(lines)

###########################################################
def quick_extract(filename: str, case: str, user_keys: dict) -> str:
    '''
    Extract the part of the cppdefs.h which correspond to the selected CASE to
    apply.

    Extra transformations: In addition we remove the #undef related to the CPP
    keys defined by the user so they don't override what user is asked.

    Parameters:
    -----------
    filename: str
        Path of the cppdefs.h file.
    case: str
        Name of the CASE to be used and for which to extract the config.
    user_keys: dict
        List of CPP keys defined and forced by user.
    '''
    # open the file and load
    with open(filename, "r") as fp:
        return quick_extract_from_source(fp.read(), case, user_keys)

###########################################################
def quick_extract_from_source(source: str, case: str, user_keys: dict) -> str:
    '''
    Extract the part of the cppdefs.h which correspond to the selected CASE to
    apply.

    Extra transformations: In addition we remove the #undef related to the CPP
    keys defined by the user so they don't override what user is asked.

    Parameters:
    -----------
    source: str
        The cppdef.h source content.
    case: str
        Name of the CASE to be used and for which to extract the config.
    user_keys: dict
        List of CPP keys defined and forced by user.
    '''

    # define some regexps to parse
    COND_START = re.compile(r"^#[ \t]*(if|ifdef|ifndef)[ \t].*")
    COND = re.compile(r"^#[ \t]*(if|elif|ifdef|ifndef)[ \t].*")
    COND_END = re.compile(r"^#[ \t]*(endif).*")

    # load & split lines
    lines = source.split('\n')

    # some state vars
    capture = False
    capture_depth = 0
    final = []
    depth = 0

    # we ignore some keys we don't want in the file.
    for skip in ['OPENMP', 'MPI', 'OPENACC', 'OPENACC_PSYCLONE']:
        user_keys[skip] = False

    # loop over all lines
    for id, line in enumerate(lines):
        # apply regexp
        is_cond_start = COND_START.match(line)
        is_cond = COND.match(line)
        is_cond_end = COND_END.match(line)

        # switch to another #elif of encounter #endif => stop instr
        if depth == capture_depth and capture and not is_cond_start and (is_cond or is_cond_end):
            capture = False

        # capture
        if capture:
            skip_user_defined = False
            for key in user_keys:
                if re.compile(f"#[ \t]*undef[ \t]+{key}").match(line):
                    skip_user_defined = True
            if not skip_user_defined:
                final.append(line)

        # start new condition
        if is_cond_start:
            depth += 1

        # the condition is the one we want (out CASE)
        if is_cond and f"defined {case}" in line:
            capture = True
            capture_depth = depth

        # this is end, pop up
        if is_cond_end:
            depth -= 1

    # ok gen final
    return {
        'case': case,
        'user_keys': user_keys,
        'extracted': final
    }

###########################################################
def render_cppdef_edit_h(infos: dict) -> str:
    '''
    Generate the cppdef_edit.h with the CASE + user_keys + extract_keys

    Parameters:
    -----------
    infos: dict
        The exracted info the format.
    '''
    # vars
    final = []

    # dump user keys
    final.append(dump_user_define(infos['case'], infos['user_keys']))

    # separator
    final.append("")
    final.append("/********** APPLYING CASE (extracted from ./cppdef_handler.py) ******************/")
    final.append("")
    final.append("/* Note: user keys has been removed */")
    final.append("")
    final += infos["extracted"]
    final.append("")

    # render
    return "\n".join(final)


###########################################################
def main() -> None:
    # config
    parser = argparse.ArgumentParser(prog='cppdef_handler', description='Handle cppdef key editing')
    parser.add_argument("CPPDEF_FILE", help="The cppdef.h to load")
    parser.add_argument("-k", "--keys", help="List of keys to enable / disable by prefixing by +/- and using comma as separator", default='')
    parser.add_argument("-c", "--case", help="Name of the selected CASE", required=True)
    parser.add_argument("-f", "--format", help="What to output (extract)", default='extract')

    # parse
    args = parser.parse_args()

    # build key map
    key: str
    user_keys = {}
    if args.keys != '':
        for key in args.keys.split(','):
            if key.startswith('-'):
                user_keys[key[1:]] = False
            elif key.startswith('+'):
                user_keys[key[1:]] = True
            else:
                user_keys[key] = True

    # gen
    print()
    print(f"/* Generated by => {' '.join(sys.argv)} */")
    print()

    # gen
    if args.format == 'extract':
        infos = quick_extract(args.CPPDEF_FILE, args.case, user_keys)
        rendered = render_cppdef_edit_h(infos)
        print(rendered)

###########################################################
TEST_CODE_1='''
#if defined BASIN
# define SELECT_BASIN
#elif defined SOLITON
# define SELECT_SOLITON
# define ANOTHER_KEY_1
#elif defined RIP
# define SELECT_RIP
# define ANOTHER_KEY_2
#endif
'''

###########################################################
def test_basic_if():
    extracted = quick_extract_from_source(TEST_CODE_1, "BASIN", {})
    assert extracted['extracted'] == [
        '# define SELECT_BASIN'
    ]

###########################################################
def test_basic_elif_1():
    extracted = quick_extract_from_source(TEST_CODE_1, "SOLITON", {})
    assert extracted['extracted'] == [
        '# define SELECT_SOLITON',
        '# define ANOTHER_KEY_1'
    ]

###########################################################
def test_basic_elif_2():
    extracted = quick_extract_from_source(TEST_CODE_1, "RIP", {})
    assert extracted['extracted'] == [
        '# define SELECT_RIP',
        '# define ANOTHER_KEY_2'
    ]

###########################################################
def test_basic_elif_1_regen():
    extracted = quick_extract_from_source(TEST_CODE_1, "RIP", {})
    gen = render_cppdef_edit_h(extracted)
    assert gen == '''\
/********** USER CONFIG (generated by ./cppdef_handler.py) ******************/
/* SELECTED CASE */
#define RIP

/* FEATURES */
#undef OPENMP
#undef MPI
#undef OPENACC
#undef OPENACC_PSYCLONE

/********** APPLYING CASE (extracted from ./cppdef_handler.py) ******************/

/* Note: user keys has been removed */

# define SELECT_RIP
# define ANOTHER_KEY_2
'''

###########################################################
def test_cppdef_BASIN():
    cmake_dir = os.path.abspath(os.path.dirname(__file__))
    cppdef_file = os.path.join(cmake_dir, "..", "OCEAN", "cppdefs.h")
    print(cppdef_file)
    extracted = quick_extract(cppdef_file, "BASIN", {})
    assert extracted['extracted'] == [
        '/*',
        '!                       Basin Example',
        '!                       ===== =======',
        '*/',
        '# define UV_ADV',
        '# define UV_COR',
        '# define UV_VIS2',
        '# define SOLVE3D',
        '# define TS_DIF2',
        '# define BODYFORCE',
        '# define ANA_GRID',
        '# define ANA_INITIAL',
        '# define ANA_SMFLUX',
        '# define ANA_STFLUX',
        '# define ANA_BTFLUX',
        '# define NO_FRCFILE',
        '# undef  RVTK_DEBUG',
        '',
    ]

###########################################################
if __name__ == "__main__":
    main()
