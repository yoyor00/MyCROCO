#!/usr/bin/env python3
###########################################################
#  CROCO cmake build system, under CeCILL-C
#  From SÃ©bastien Valat (INRIA & LJK) - 2023
#  CROCO website : http://www.croco-ocean.org
###########################################################

###########################################################
# The goal of this file is to extract the CPPKEY par from cppdefs.h
# corresponding to the CASE selected in the build system.
#
# In addition of this extraction we also remove the #undef related
# to the user_keys so the user can easily activate de-activate what
# he wants in the cppdefs_override.h file.

###########################################################
import os
import re
import sys
import argparse


###########################################################
def dump_user_define(case: str, user_keys: dict) -> str:
    """
    Dump the user defined CPP keys.

    Parameters:
    -----------
    case: str
        The selected case.
    user_keys: dict
        List of CPP keys defined and forced by user.
    """
    # vars
    lines = []

    # print separator
    lines.append(
        "/********** USER CONFIG (generated by ./cppdef_handler.py) ******************/"
    )

    # case
    lines.append("/* SELECTED CASE */")
    lines.append(f"#define {case}")
    lines.append("")

    # dump all keys
    lines.append("/* FEATURES */")
    for key, value in user_keys.items():
        if value:
            lines.append(f"#define {key}")
        else:
            lines.append(f"#undef {key}")

    # ok
    return "\n".join(lines)


###########################################################
def quick_extract(filename: str, case: str, user_keys: dict) -> str:
    """
    Extract the part of the cppdefs.h which correspond to the selected CASE to
    apply.

    Extra transformations: In addition we remove the #undef related to the CPP
    keys defined by the user so they don't override what user is asked.
    And we remove the #define related to the CPP
    keys unwanted by the user so they don't override what user is asked.

    Parameters:
    -----------
    filename: str
        Path of the cppdefs.h file.
    case: str
        Name of the CASE to be used and for which to extract the config.
    user_keys: dict
        List of CPP keys defined and forced by user.
    """
    # open the file and load
    with open(filename, "r") as fp:
        return quick_extract_from_source(fp.read(), case, user_keys)


###########################################################
def quick_extract_from_source(source: str, case: str, user_keys: dict) -> str:
    """
    Extract the part of the cppdefs.h which correspond to the selected CASE to
    apply.

    Extra transformations: In addition we remove the #undef related to the CPP
    keys defined by the user so they don't override what user is asked.

    Parameters:
    -----------
    source: str
        The cppdef.h source content.
    case: str
        Name of the CASE to be used and for which to extract the config.
    user_keys: dict
        List of CPP keys defined and forced by user.
    """

    # define some regexps to parse
    COND_START = re.compile(r"^#[ \t]*(if|ifdef|ifndef)[ \t].*")
    COND = re.compile(r"^#[ \t]*(if|elif|ifdef|ifndef)[ \t].*")
    COND_END = re.compile(r"^#[ \t]*(endif).*")

    # load & split lines
    lines = source.split("\n")

    # some state vars
    capture = False
    capture_depth = 0
    final = []
    depth = 0

    # we ignore some keys we don't want in the file.
    for skip in ["OPENMP", "MPI", "OPENACC", "OPENACC_PSYCLONE"]:
        user_keys[skip] = False

    # loop over all lines
    for id, line in enumerate(lines):
        # apply regexp
        is_cond_start = COND_START.match(line)
        is_cond = COND.match(line)
        is_cond_end = COND_END.match(line)

        # switch to another #elif of encounter #endif => stop instr
        if (
            depth == capture_depth
            and capture
            and not is_cond_start
            and (is_cond or is_cond_end)
        ):
            capture = False

        # capture
        if capture:
            skip_user_defined = False
            for key in user_keys:
                if re.compile(f"#[ \t]*undef[ \t]+{key}").match(line):
                    skip_user_defined = True
                if re.compile(f"#[ \t]*define[ \t]+{key}").match(line):
                    skip_user_defined = True
            if not skip_user_defined:
                final.append(line)

        # start new condition
        if is_cond_start:
            depth += 1

        # the condition is the one we want (out CASE)
        if is_cond and f"defined {case}" in line:
            capture = True
            capture_depth = depth

        # this is end, pop up
        if is_cond_end:
            depth -= 1

    # ok gen final
    return {"case": case, "user_keys": user_keys, "extracted": final}


###########################################################
def render_cppdef_edit_h(infos: dict) -> str:
    """
    Generate the cppdef_edit.h with the CASE + user_keys + extract_keys

    Parameters:
    -----------
    infos: dict
        The exracted info the format.
    """
    # vars
    final = []

    # dump user keys
    final.append(dump_user_define(infos["case"], infos["user_keys"]))

    # separator
    final.append("")
    final.append(
        "/********** APPLYING CASE (extracted from ./cppdef_handler.py) ******************/"
    )
    final.append("")
    final.append("/* Note: user keys has been removed */")
    final.append("")
    final += infos["extracted"]
    final.append("")

    # render
    return "\n".join(final)


###########################################################
def main() -> None:
    # config
    parser = argparse.ArgumentParser(
        prog="cppdef_handler", description="Handle cppdef key editing"
    )
    parser.add_argument("CPPDEF_FILE", help="The cppdef.h to load")
    parser.add_argument(
        "-k",
        "--keys",
        help="List of keys to enable / disable by prefixing by +/- and using comma as separator",
        default="",
    )
    parser.add_argument("-c", "--case", help="Name of the selected CASE", required=True)
    parser.add_argument(
        "-f", "--format", help="What to output (extract)", default="extract"
    )

    # parse
    args = parser.parse_args()

    # build key map
    key: str
    user_keys = {}
    if args.keys != "":
        for key in args.keys.split(","):
            if key.startswith("-"):
                user_keys[key[1:]] = False
            elif key.startswith("+"):
                user_keys[key[1:]] = True
            else:
                user_keys[key] = True

    # gen
    print()
    print(f"/* Generated by => {' '.join(sys.argv)} */")
    print()

    # gen
    if args.format == "extract":
        infos = quick_extract(args.CPPDEF_FILE, args.case, user_keys)
        rendered = render_cppdef_edit_h(infos)
        print(rendered)


###########################################################
TEST_CODE_1 = """
#if defined BASIN
# define SELECT_BASIN
#elif defined SOLITON
# define SELECT_SOLITON
# define ANOTHER_KEY_1
#elif defined RIP
# define SELECT_RIP
# define ANOTHER_KEY_2
#endif
"""


###########################################################
def test_basic_if():
    extracted = quick_extract_from_source(TEST_CODE_1, "BASIN", {})
    assert extracted["extracted"] == ["# define SELECT_BASIN"]


###########################################################
def test_basic_elif_1():
    extracted = quick_extract_from_source(TEST_CODE_1, "SOLITON", {})
    assert extracted["extracted"] == [
        "# define SELECT_SOLITON",
        "# define ANOTHER_KEY_1",
    ]


###########################################################
def test_basic_elif_2():
    extracted = quick_extract_from_source(TEST_CODE_1, "RIP", {})
    assert extracted["extracted"] == ["# define SELECT_RIP", "# define ANOTHER_KEY_2"]


###########################################################
def test_basic_elif_1_regen():
    extracted = quick_extract_from_source(TEST_CODE_1, "RIP", {})
    gen = render_cppdef_edit_h(extracted)
    assert (
        gen
        == """\
/********** USER CONFIG (generated by ./cppdef_handler.py) ******************/
/* SELECTED CASE */
#define RIP

/* FEATURES */
#undef OPENMP
#undef MPI
#undef OPENACC
#undef OPENACC_PSYCLONE

/********** APPLYING CASE (extracted from ./cppdef_handler.py) ******************/

/* Note: user keys has been removed */

# define SELECT_RIP
# define ANOTHER_KEY_2
"""
    )


###########################################################
def test_cppdef_BASIN():
    cmake_dir = os.path.abspath(os.path.dirname(__file__))
    cppdef_file = os.path.join(cmake_dir, "..", "OCEAN", "cppdefs.h")
    print(cppdef_file)
    extracted = quick_extract(cppdef_file, "BASIN", {})
    assert extracted["extracted"] == [
        "/*",
        "!                       Basin Example",
        "!                       ===== =======",
        "*/",
        "# define UV_ADV",
        "# define UV_COR",
        "# define UV_VIS2",
        "# define SOLVE3D",
        "# define TS_DIF2",
        "# define BODYFORCE",
        "# define ANA_GRID",
        "# define ANA_INITIAL",
        "# define ANA_SMFLUX",
        "# define ANA_STFLUX",
        "# define ANA_BTFLUX",
        "# define NO_FRCFILE",
        "# undef  RVTK_DEBUG",
        "",
    ]


###########################################################
if __name__ == "__main__":
    main()
