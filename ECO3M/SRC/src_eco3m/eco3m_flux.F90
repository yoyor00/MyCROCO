!***************************************************************************
!***************************************************************************
!Copyright or © or Copr. CNRS/IRD/Université de la Méditerranée
!contributor(s) : Melika BAKLOUTI & Vincent FAURE (10/10/2006)
!
!melika.baklouti@univ-amu.fr; 
!
!This software (Eco3M) is a computer program whose purpose is to perform 
!biogeochemical or coupled physical-biogeochemical modelling.
!
!This software is governed by the CeCILL license under French law and
!abiding by the rules of distribution of free software. You can  use, 
!modify and/ or redistribute the software under the terms of the CeCILL
!license as circulated by CEA, CNRS and INRIA at the following URL
!"http://www.cecill.info". 
!
!As a counterpart to the access to the source code and  rights to copy,
!modify and redistribute granted by the license, users are provided only
!with a limited warranty  and the software''s author,  the holder of the
!economic rights,  and the successive licensors  have only  limited
!liability. 
!
!In this respect, the user''s attention is drawn to the risks associated
!with loading,  using,  modifying and/or developing or reproducing the
!software by the user in light of its specific status of free software,
!that may mean  that it is complicated to manipulate,  and  that  also
!therefore means  that it is reserved for developers  and  experienced
!professionals having in-depth computer knowledge. Users are therefore
!encouraged to load and test the software''s suitability as regards their
!requirements in conditions enabling the security of their systems and/or 
!data to be ensured and,  more generally, to use and operate it in the 
!same conditions as regards security. 
!
!The fact that you are presently reading this means that you have had
!knowledge of the CeCILL license and that you accept its terms.
!***************************************************************************
!***************************************************************************
!-----------------------------------------------------------------------------------------------
    
    subroutine eco3m_flux_init
    
 !> Initialisation of the flux matrix FLUX_VAL and of the FLUX_PAR array (list of parameters)
 !! (dynamical allocation and setting of the subprocess parameters) 
 !! In INI mode, it also generates the "call.inc"
 !! file thait contains the flux calculation calls.
 !!
 !! \author Melika Baklouti, Vincent Faure
 !! \author Nicolas Barrier

!-----------------------------------------------------------------------------------------------
   !-- global variables    
   use eco3m_string
   use mod_eco3m_id_extract, only: f_proc2id  ! Module for the identification of processes
   use mod_eco3m_files !  Module that contains the ID of files
   use mod_eco3m
   use mod_eco3m_outputs, only : num_outflux
   implicit none

   ! Local variables
   integer :: i, j, k
   integer :: ili, jcol
   integer :: istat=0

   integer :: nbproc_flux  !< Number of process flux defined in the config.ini file
   integer :: idproc_mat  !< Index of current biogeochem. process (function) within the configuration file

    nbfunc_max = 0
    idproc_mat = 0
#ifdef INI
! In INI mode, writing of the call.inc file
! Opening of the call.inc file and writing of a header in the file
    Open(file_call_id, FILE="call.inc")
    write(file_call_id,*)
    write(file_call_id,*)
    write(file_call_id,*) "! This file is automatically generated by the Eco3M program in INI mode"
    write(file_call_id,*) "! It contains the call to the functions for the calculation of fluxes between biological variables"
    write(file_call_id,*) 
    write(file_call_id,*) 
#endif
! Allocation of the FLUX_VAL matrix
   if (.not. allocated (FLUX_VAL)) ALLOCATE(FLUX_VAL(nbvar, nbvar), STAT=istat)
   if (istat /= 0) write(*,*) 'pb with the allocation of FLUX_VAL'

! Desallocation of idproc pointers
   do jcol = 1, nbvar
       do ili = 1, nbvar
           NULLIFY(FLUX_VAL(ili, jcol)%idproc)
       enddo
   enddo

! Call to the subroutine that processes the FLUX_VAL fields (except %val) 
! using the config.ini file:
! - allocates some fields of the FLUX_PAR/FLUX_VAL matrices
! - writes the call.inc file containing the fluxes of the biogeochemical model  
        call fscanf_flux (nbproc_flux)

!-- Save biogeochemical fluxes
#ifdef INI 
#ifdef SAVE_FLUX
        call fwritef_save_subproc(nbproc_flux)
#endif
#endif

! close config files
#ifdef INI
        close(file_call_id)
#ifdef SAVE_FLUX
! close the file which enables to save the detail of the biogeochemical fluxes
        close(file_saveflx_id)
#endif
#endif
  ! Dynamical allocation of the flux matrix components:
  do i = 1, nbvar  
       ! checks whether the pointer FLUX_VAL(i)%idproc is associated
       ! if so, allocate the flux_val%val matrix and initialize it to 0
    do j = 1, nbvar
       if (Associated (FLUX_VAL(i, j)%idproc)) then
           Allocate(FLUX_VAL(i, j)%val(nx_min:nx_max, ny_min:ny_max,1:nz_max), &
                                STAT=istat)
           if (istat /= 0) write(*,*) 'pb with the allocation of FLUX_VAL(', i, j, ')%val'
           FLUX_VAL(i, j)%val = 0.0d0  ! initialisation of the flux values
       endif
    enddo
  enddo

  ! Writing in log file
#ifdef INI
        write(file_CR_id,*) " ===================================== Eco3M Flux calculation "
        do ili = 1, nbvar
            do jcol = 1, nbvar
                if(ASSOCIATED(FLUX_VAL(ili, jcol)%idproc)) then
                    write(file_CR_id, *) ili, ';', jcol, ':', &
                        (FLUX_VAL(ili,jcol)%idproc(k), '/', k=1,size(FLUX_VAL(ili,jcol)%idproc))
                endif
            end do
        end do

        write(file_CR_id,*)
        write(file_CR_id,*)  'Flux parameters'
        do i = 1, size(FLUX_PAR)
            write(file_CR_id, '(A, I3,I3,A1,A10,A3)')  &
                "================ ", FLUX_PAR(i)%ipos ,' > ', &
                PROC_MOD(FLUX_PAR(i)%idproc)%nomproc, ' : '
            write(file_CR_id,'(A7,A1,G10.3,A1,$)') &
                (PROC_MOD(FLUX_PAR(i)%idproc)%nompar(k),'=',   &
                FLUX_PAR(i)%valpar(k),';',k=1,size(FLUX_PAR(i)%valpar))
            write(file_CR_id,*)
        enddo
        write(file_CR_id,*) 
#endif
    end subroutine eco3m_flux_init
!----------------------------------------------------------------------------------------
    subroutine fscanf_flux (nbproc_flux)
    
    !> Reading of the flux-related settings in the *config.ini* file. 
    !! Dynamical allocation of the FLUX_PAR and FLUX_VAL arrays.
    !! In INI mode, it also handles the writing of the "call.inc" file for the fluxes. 
    !!
    !! \author Melika Baklouti
    !! \author Nicolas Barrier
    !! \date 2015-11-09
!----------------------------------------------------------------------------------------
   !-- global variables    
  use eco3m_string
  use mod_eco3m_id_extract, only: f_proc2id  ! Module for the identification of processes
  use mod_eco3m_files !  Module that contains the ID of files
  use mod_eco3m
  implicit none

   ! variable declaration
  integer:: nbproc_flux

   ! local variables
  character(L_CHAIN) :: c_jcol, c_ili
  integer :: i
  integer :: ili, jcol
  integer :: istat=0 
  integer :: errlec=0
  integer :: lon_c_jcol, lon_c_ili
  Character(L_CHAIN) :: tempo, tempo2, chaine_proc
  Character(L_CHAIN) :: chaine

  integer :: idproc_mat ! index of the current process function among all the functions (global index)
  integer :: nbproc_loc, inbmult !number of process functions in a given flux; number of "x" signs in a given flux

        
! ===================================================================================
! Reading in the "config.ini" file of the total number of functions (sub process)
! This is done by looping over all the lines, until an integer is reached
! ===================================================================================
   do  
         Read(file_config_id,*,iostat=errlec) chaine

         if (errlec /= 0) then 
             write(*,*) 'pb with the reading of ', trim("FLUX_PAR"), " in the config.ini file"
             stop
         end if

! if the first character is #, then we keep reading the lines
         if (chaine(1:1) == '#') cycle
!        if (trim(adjustl(chaine)) == 'finflux') exit

! reading of the cumulated number of processes (i.e. functions) used in all the
! FLUX_VAL matrix
         Read(chaine,*) nbproc_flux

! Allocation of the FLUX_PAR matrix
! Note that the FLUX_VAL  matrix are initialised in the sub_init.F90 scipt
         if (.not. allocated (FLUX_PAR)) Allocate(FLUX_PAR(nbproc_flux), STAT=istat)
         if (istat /= 0) write(*,*) 'pb with the allocation of FLUX_PAR'
         exit
  enddo

! ====================================================================
! Loop on the FLUX matrix of the "config.ini" file.
! The processes that are in fact REAL processes will be stored in the FLUX_VAL matrix
! ====================================================================
! Initialisation of the number of direct mass fluxes (between two explicit state
! variables or between an explicit state variable and a variable non explicitly
! represented in the model) in the flux matrix
  nb_bio_flux = 0

! Initialisation of the maximum number of subprocesses within a flux calculation
  nbfunc_max = -1  

! initialisation of the idproc_mat variable, which is the
! id of the current sub-process among ALL the processes of the FLUX_VAL
! matrix (global index)
  idproc_mat = 0
  do 
       Read(file_config_id,"(A)",iostat=errlec) chaine
       if (errlec /= 0) then 
           write(*,*) 'errlec =', errlec
           stop 'pb with the reading of flux statements in the config.ini file'
       endif

    ! If the string that has been read is #, then we keep reading
       if (chaine(1:1) == '#') cycle

    ! If the string that has been read is finflux, we exit the loop
       if (trim(adjustl(chaine)) == 'finflux') exit

    ! Incrementation of the number of non-zero fluxes in the flux matrix
       nb_bio_flux = nb_bio_flux + 1

    ! reading of the line index (ili) and eventually the column index (jcol)
       tempo = f_chain(chaine, 1, ':')
       tempo2 = f_chain(tempo, 1, ';')
       read(tempo2,*) ili
       c_ili = f_Int2chain(ili,lon_c_ili)
       tempo2=f_chain(tempo, 2, ';')

    ! If the tempo2 string is empty, then we have a self process (i.e. flux from ili to ili
       if (trim(tempo2) == "") then
           jcol = ili
       else
           read(tempo2,*) jcol
       end if
       c_jcol=f_Int2chain(jcol,lon_c_jcol)

    ! computation of the number of functions  within the ili --> jcol flux 
    ! we isolate the part of the string that contains only the processes and signs
    ! (i.e. we remove the string "ili;jcol:")
       chaine_proc=chaine(len_trim(tempo)+2:len_trim(chaine))
#ifdef MODTEST
       write(*,*) 'chaine proc: ', chaine_proc
#endif
    
    ! computation of the number of subprocesses within the flux (brackets included)
       nbproc_loc = f_nschain(chaine_proc, ':')
    
    ! update of the  maximum number of ss_flux in a given  biogeochemical flux
      if (nbfunc_max < nbproc_loc) nbfunc_max = nbproc_loc

    ! we look for the number of 'x' signs   (through a chain of 3 characters in case
    ! where the 'x' letter would be used in the name of a process  function   
       inbmult=f_nschain_seq(chaine_proc,':x;',3) - 1

    !-- Calculation of the effective nb of sub_fluxes in the flux from ili to jcol       
       FLUX_VAL(ili,jcol)%nb_sflux = nbproc_loc - inbmult

    ! Dynamical allocation of the idproc array, which contains the ID of effective 
    ! (i.e. biological) sub-processes
       Allocate (FLUX_VAL(ili,jcol)%idproc(nbproc_loc),STAT=istat)
       if (istat /= 0) then 
           write(*,"(A, I3, A, I3, A)") "Problem with the dynamical allocation of FLUX_VAL(", &
               ili, ", ", jcol, ")%idproc array"
           write(*,*) "This program will be stopped"
           stop
       end if
   !-- Processing of each flux
      call process_subflux(chaine,nbproc_flux,nbproc_loc,idproc_mat,ili,jcol)
  end do  

 
    end subroutine fscanf_flux
!----------------------------------------------------------------------------------------------------
    subroutine process_subflux(chaine,nbproc_flux,nbproc_loc,idproc_mat,ili,jcol)
    
    !> Processes the sub-fluxes of a chain of character 
    !! corresponding to a flux calculation in the case of fluxes are
    !! not saved. It allocates and assigns values to the FLUX_PAR(idproc)%valpar array. In INI mode, 
    !! it also writes the "call.inc" file used for flux calculation. No intermediary variable is used.
    !! \author Melika Baklouti
    !! \author Nicolas Barrier
    !! \date 07/2017
!------------------------------------------------------------------------------------------------------
   !-- global variables    
    use eco3m_string
    use mod_eco3m_id_extract, only: f_proc2id  ! Module for the identification of processes
    use mod_eco3m_files !  Module that contains the ID of files
    use mod_eco3m
    implicit none
   
   ! subroutine arguments
    character(l_chain), intent(in) :: chaine   !< String corresponding to a flux in the
     !! **call.inc** file
    integer, intent(in) :: nbproc_flux   !< Number of functions (subprocesses) in the biogeochemical model
    integer, intent(in) :: nbproc_loc   !< Number of subprocesses within the current flux VAR(ili) --> VAR(jcol)
    integer :: idproc_mat ! index of the current process function among all the functions (global index)
    integer, intent(in) :: ili   !< Row index in the FLUX_VAL matrix
    integer, intent(in) :: jcol  !< Column index in the FLUX_VAL matrix

  ! local variables
    character(len=L_CHAIN) :: c_ili, c_jcol
    integer :: ii,istat
    character(len=L_CHAIN) :: tempo, tempopo, nomproc_tempo
    integer :: idtemp, iposfin, iposini
    integer :: k
    Character(len=L_VAR)   :: signe
    integer :: lon_c_ili, lon_c_jcol
    Character(len=L_VAR_LG) :: nomsub
    character(len=L_CHAIN) :: ichain2
    integer :: dim_param, kk, lon_ichain2

    character(L_VAR) :: signe_facteur
    integer :: iisx

!-- integer to string conversion of ili and jcol
    c_ili = f_Int2chain(ili,lon_c_ili)
    c_jcol=f_Int2chain(jcol,lon_c_jcol)

!-- write in the "call.inc"  (INI mode only)
#ifdef INI
 write(file_call_id, *) 'FLUX_VAL(',c_ili(:lon_c_ili),',',c_jcol(:lon_c_jcol), & 
            ')%val = & '
#endif

! Loop over all the flux sub-processes  corresponding to the FLUX(ili, jcol)
 do ii = 1, nbproc_loc  ! Begining of the "local" loop over processes (including operators)
           
! we iterate the index of the FLUX_PAR matrix (the idproc_mat index)
   idproc_mat = idproc_mat + 1

! if the total number of processes exceeds the one defined in the file
! the program is stopped
   if (idproc_mat > nbproc_flux) then
        write(*,"(A, I3, A, I3)") 'Number of cumulated process, ', idproc_mat, &
             ', is greater than the one indicated in the file, ',  nbproc_flux
        write(*,*) "This program will be stopped"
        STOP
   end if
! Reading the sign of the sub-process 
   tempo = f_chain(f_chain(chaine, ii+1, ':'), 1, ';')
   read(tempo,*) signe 
   signe_facteur = TRIM(ADJUSTL(signe))

! If the signe contains a x sign, conversion
! into a * (multiplication in Fortran)
   iisx =  index(signe_facteur, 'x')
   if ( iisx > 0 ) signe_facteur(iisx:iisx) = '*'

!-- partial filling of table FLUX_PAR
   FLUX_PAR(idproc_mat)%ipos(1) = ili
   FLUX_PAR(idproc_mat)%ipos(2) = jcol
   FLUX_PAR(idproc_mat)%signe = signe_facteur  
            
! Reading  the name of the sub-process (parameters included)
   nomproc_tempo = f_chain(f_chain(chaine,ii + 1, ':'), 2, ';')
! Removing the brackets to only keep the name
   tempo = f_chain(nomproc_tempo, 1, '(') 
! we retrieve the index of the process
   idtemp = f_proc2id(tempo)

! Update of the idproc array, which contains the index of sub-processes within the flux
   FLUX_VAL(ili, jcol)%idproc(ii) = idtemp
! Update of the flux_par array
   FLUX_PAR(idproc_mat)%idproc = idtemp

#ifdef INI
      if (len_trim(signe_facteur)>1) then
         write(file_call_id,'(a8,a4)') adjustl(signe_facteur), '* &'
       else
         write(file_call_id,'(a1,a2)') signe_facteur(1:1), ' &'
      endif
#endif
   write(nomsub,'(a)') PROC_MOD(idtemp)%nomsub
   nomsub=trim(adjustl(nomsub))

! Looking for the total number of parameters 
   iposini=index(nomproc_tempo,'(')  ! position of the opening bracket
   iposfin=index(nomproc_tempo,')')  ! position of the closing bracket

! tempo contains only what is between brackets 
   tempo=nomproc_tempo(iposini+1:iposfin-1)
   dim_param = f_nschain(tempo,'>')  ! nb of arguments for the current process

! If the number of parameters for a given process provided in the config.ini file
! differs from the one given in the modele.def file, it's potentially normal
! if some or the arguments are optional. A warning is however delivered with
! the MODTEST cpp key
!
#ifdef MODTEST
   if (dim_param /= PROC_MOD(idtemp)%nbpar) then
            write(*,"(A, A, A, I3, A, I3, A, I3, A)") &
            "Warning: Number of parameters in process ", PROC_MOD(idtemp)%nomproc, &
      &     "in FLUX_PAR(", idproc_mat, ")  is wrong. ", PROC_MOD(idtemp)%nbpar, &
           " were expected, while ", dim_param, " were provided.",&
         & " Check that everything is fine."
   endif
#endif
   if (associated (FLUX_PAR(idproc_mat)%valpar)) NULLIFY(FLUX_PAR(idproc_mat)%valpar)

   if (dim_param >=1) then  !case where the function has at least one parameter

! Dynamical allocation of the flux parameter values array
      Allocate(FLUX_PAR(idproc_mat)%valpar(dim_param),STAT=istat)
      if (istat /= 0) write(*,*) "pb with the allocation of FLUX_PAR%valpar"
     
! Filling the flux_parameter array 
      do kk = 1, dim_param 
          tempopo = f_chain(tempo, kk, '>')
          Read(tempopo,*) FLUX_PAR(idproc_mat)%valpar(kk)
      enddo
   endif

#ifdef INI 
   if (associated(FLUX_PAR(idproc_mat)%valpar)) then ! case where the function has
                                                    ! at least one parameter

!  If the sub-process has any arguments (i.e. parameters)
!          dim_param = size(FLUX_PAR(idproc_mat)%valpar)

! Writing  the f_process(ili, jcol, &) string
          write(file_call_id,*) '  ', nomsub(1:len_trim(nomsub)), '(', &
               trim(c_ili), ',', trim(c_jcol), ', &'

! We loop over all the parameters and we write the arguments as FLUX_PAR(3)%valpar(k), &
          ichain2=f_Int2chain(idproc_mat,lon_ichain2)
          do kk = 1, dim_param-1
              write(file_call_id,*) '     ', 'FLUX_PAR', '(', ichain2(:lon_ichain2)  ,&
                            ')%valpar(',  kk  ,')', ', & '
          enddo

! For the last process (and the last parameter), we remove the & string 
          if (ii == nbproc_loc) then
               write(file_call_id,*) '     ', 'FLUX_PAR', '(',  ichain2(:lon_ichain2)  ,&
                            ')%valpar(',  dim_param  ,') )'
          else
               write(file_call_id,*) '     ', 'FLUX_PAR', '(',  ichain2(:lon_ichain2)  ,&
                            ')%valpar(',  dim_param  ,') ) &'
         endif

   else ! if the process function has no argument, we write f_name(ili, jcol)
          dim_param=0        
          if (ii == nbproc_loc) then
              write(file_call_id,*)'  ',nomsub(1:len_trim(nomsub)),'(', &
                   trim(c_ili),',',trim(c_jcol), ') '
         else
              write(file_call_id,*)'  ',nomsub(1:len_trim(nomsub)),'(', &
                            trim(c_ili),',',trim(c_jcol), ') & '
         end if

   endif
#endif
enddo  ! End local process loop

#ifdef INI
 write(file_call_id, *)' '
 write(file_call_id, *)' '
#endif

END SUBROUTINE process_subflux
        
!------------------------------------------------------------------------------------------------------------
#ifdef INI
#ifdef SAVE_FLUX
    
    subroutine fwritef_save_subproc(nbproc_flux)

  !> Writes a sub-process in the "call_save_flux.inc" file in the form
  !! **ss_flux(:,:,:,id) = f_process(...)**. 
  !! \note Only used if the *SAVE_FLUX* key is activated
  !! \warning The signs associated with the sub-processes are not included here
  !! \author Melika Baklouti, Vincent Faure, Nicolas Barrier
  !! \date 2018-08-28
!------------------------------------------------------------------------------------------------------------
 !-- global variables    
 use eco3m_string
 use mod_eco3m_id_extract, only: f_proc2id  ! Module for the identification of processes
 use mod_eco3m_files !  Module that contains the ID of files
 use mod_eco3m
 implicit none
 
 integer :: nbproc_flux
 ! local variables
 integer :: idproc_mat !< global index of the current subprocess (used in the *FLUX_PAR* array)
 integer :: ili, jcol !< index of the state variables of the VAR(ili) --> VAR(jcol) biogeochemical flux
 character(len=L_CHAIN) :: c_ili  !< string corresponding to the ili raw of the matrix
 character(len=L_CHAIN) :: c_jcol !< string corresponding to the jcol column of the matrix
 character(len=L_VAR_LG) :: nomsub
 integer :: lon_c_ili, lon_c_jcol
 integer :: kk, dim_param, lon_ichain2
 integer:: idproc_loc,nbproc_loc!< local index of the current subprocess (reinitialized each ili --> jcol flux)
 character(len=L_CHAIN)  :: ichain2
 character(len=L_VAR) :: signe_facteur
 integer :: ip

! Opening the file in which the instructions for flux saving will be written
 Open(file_saveflx_id,FILE="call_save_flux.inc")

 write(file_saveflx_id,*) "! This file is automatically generated by a the Eco3M program in INI mode"
 write(file_saveflx_id,*) "! It contains the details of the functions involved in the fluxes between"
 write(file_saveflx_id,*) "! biological variables"
 write(file_saveflx_id,*) 
 write(file_saveflx_id,*) "! maximum number of functions per biogeochemical flux =",nbfunc_max
 write(file_saveflx_id,*) 
 write(file_saveflx_id,*) 

!-- initialisation of the global index of 
 idproc_mat =1 

!-- loop on direct biogeochemical fluxes
  do ip = 1, nb_bio_flux
!     if (Associated (FLUX_VAL(ili, jcol)%idproc)) then
       ! integer to string conversion of ili and jcol
         ili =  FLUX_PAR(idproc_mat)%ipos(1) 
         jcol = FLUX_PAR(idproc_mat)%ipos(2) 
         c_ili = f_Int2chain(ili,lon_c_ili)
         c_jcol=f_Int2chain(jcol,lon_c_jcol)

       ! write some instructions/information in the "sub_call_flux.inc" 
         write(file_saveflx_id,*) "nbproc_loc = size(FLUX_VAL(",c_ili(:lon_c_ili),"," &
                                                             ,c_jcol(:lon_c_jcol) ,")%idproc)"
         write(file_saveflx_id,*) "Allocate(ss_flux(nbproc_loc+1,nx_min:nx_max,ny_min:ny_max,nz_max))"
       ! nb of ss_flux in the ili --> jcol flux        
         nbproc_loc = size((FLUX_VAL(ili,jcol)%idproc))
      
         !-- loop on ss_fluxes
         do idproc_loc = 1,nbproc_loc
       
          ! We recover the name of the process function n°(idproc_mat)
           write(nomsub,'(a)')PROC_MOD(FLUX_PAR(idproc_mat)%idproc)%nomsub
           nomsub=trim(adjustl(nomsub))
    !    -------------------------------------
    !    ---- function with parameters  ------
    !    -------------------------------------
           if (size(FLUX_PAR(idproc_mat)%valpar )/=0 ) then

    ! Dimension of parameters vector :      
    !------------------------------------
             dim_param     = size(FLUX_PAR(idproc_mat)%valpar)
             signe_facteur = TRIM(ADJUSTL(FLUX_PAR(idproc_mat)%signe))
!
             write(file_saveflx_id,*) ' '
             write(file_saveflx_id,*) 'ss_flux(',idproc_loc,',:,:,:) =  &'
             if (signe_facteur(1:1) /= '*') then
                if (len_trim(signe_facteur)>1) then
                   write(file_saveflx_id,'(a1,a8,a5)') '(',signe_facteur, ') * &'
                else
                   write(file_saveflx_id,'(a,a1,a6)') '(',signe_facteur(1:1), '1) *&'
                endif
             endif
             write(file_saveflx_id,*) '',nomsub(1:len_trim(nomsub)),'(', &
                    c_ili(:lon_c_ili),',',c_jcol(:lon_c_jcol), ', &'

      ! -- writing the function parameters 
             ichain2=f_Int2chain(idproc_mat,lon_ichain2)
             do kk=1,dim_param-1
                write(file_saveflx_id,*) '     FLUX_PAR(',  ichain2(:lon_ichain2)  ,&
                           ')%valpar(',  kk  ,')', ', & '
             enddo

             write(file_saveflx_id,*) '     FLUX_PAR(',  ichain2(:lon_ichain2)  ,&
                         ')%valpar(',  dim_param  ,') )'
           ! -----------------------------------------------------------------
           else !----  function without parameters ------
           ! -----------------------------------------------------------------
             dim_param=0
             signe_facteur =TRIM(ADJUSTL(FLUX_PAR(idproc_mat)%signe))

             write(file_saveflx_id,*) ' '
             write(file_saveflx_id,*) 'ss_flux(',idproc_loc,',:,:,:) =  &'

             if (signe_facteur(1:1)/='*') then
               if (len_trim(signe_facteur)>1) then
                  write(file_saveflx_id,'(a1,a8,a5)') '(',signe_facteur, ') * &'
               else
                  write(file_saveflx_id,'(a,a1,a6)') '(',FLUX_PAR(idproc_mat)%signe, '1) * &'
               endif
             endif

             write(file_saveflx_id,*)'  ',nomsub(1:len_trim(nomsub)),'(', &
                                    c_ili(:lon_c_ili),',',c_jcol(:lon_c_jcol),')'
            endif
!
      ! Saving in output files
           if (idproc_loc == nbproc_loc )  then
             write(file_saveflx_id,'(A3)') ''
      ! the ili --> jcol total flux is written in the last column of the ss_flux table:
             write(file_saveflx_id,"(A, I3, A, I3, A)") &
            "    ss_flux(nbproc_loc+1,:,:,:) = FLUX_VAL(", ili, ",", jcol, ")%val"
             write(file_saveflx_id,'(A3)') ''
             write(file_saveflx_id, "(A, I4,A,I4,A,I4,A)") "call eco3m_write_fluxoutputs(ss_flux,", &
            ili, ", ",jcol, ", ", nbproc_loc, ")"
             write(file_saveflx_id, *) 
             write(file_saveflx_id,*) 'deallocate (ss_flux)'
             write(file_saveflx_id, *) "! =========================================="
           endif
           write(file_saveflx_id, *) 
           write(file_saveflx_id,*) ''
           ! update of the global index
           idproc_mat = idproc_mat + 1
    enddo
!  endif
 enddo
end subroutine fwritef_save_subproc
#endif
#endif
!------------------------------------------------------------------------------------------------------------
